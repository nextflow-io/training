= DSL2 and modules

== Basic concepts

DSL2 is a syntax extension to DSL1, developed primarily to allow the definition of module libraries and simplifies the writing of complex data analysis pipelines.

To ensure backward compatibility with DSL1 you have to explicitly enable DSL2 by adding the following line at the beginning of each workflow script: 

----
nextflow.enable.dsl=2
----

DSL2 core features include:

* Separation of processes from their invocation.
* Use of a `workflow` directive to execute specific processes.
* Storage and re-use of processes from module files.
* Update of specific syntax and definitions

To demonstrate the differences to DSL1, we will convert the first script we created earlier (`hello.nf`) into DSL2.

== Process

=== Process definition

DSL2 separates the definition of a process from its invocation. The process definition follows the usual syntax as described in the process https://www.seqera.io/training/#_processes[documentation]. The only difference is that the `from` and `into` channel declarations now have to be omitted. By removing the preset channels `from` and `into`, we allow the process to accept any value channel without needing to specify its channel name.

[discrete]
=== DSL1 syntax

[source,nextflow,linenums]
----
#!/usr/bin/env nextflow

params.greeting = 'Hello world!'
greeting_ch = Channel.from(params.greeting)

process splitLetters {

    input:
    val x from greeting_ch

    output:
    file 'chunk_*' into letters_ch

    """
    printf '$x' | split -b 6 - chunk_
    """
}
----

[discrete]
=== DSL2 syntax

[source,nextflow,linenums]
----
#!/usr/bin/env nextflow

nextflow.enable.dsl=2

params.greeting = 'Hello world!'
greeting_ch = Channel.from(params.greeting)

process splitLetters {

    input:
    val x

    output:
    file 'chunk_*'

    """
    printf '$x' | split -b 6 - chunk_
    """
}
----

=== Workflow scope

To run this process in DSL2, we have to invoke it in the `workflow` scope, passing the expected input channels as parameters as it if were a custom function. For example:

[source,nextflow,linenums]
----
workflow {
    splitLetters(greeting_ch)
}
----

IMPORTANT: A `process` can only be invoked once in the same `workflow` definition.

Next, we can define additional processes within the script and add another call to the `workflow`` directive, thereby separating the processes into 'submodules'. 

[source,nextflow,linenums]
----
#!/usr/bin/env nextflow

nextflow.enable.dsl=2

params.greeting = 'Hello world!'
greeting_ch = Channel.from(params.greeting)

process splitLetters {

    input:
    val x

    output:
    file 'chunk_*'

    """
    printf '$x' | split -b 6 - chunk_
    """
}

process convertToUpper {

    input:
    file y

    output:
    stdout

    """
    cat $y | tr '[a-z]' '[A-Z]' 
    """
}

workflow {
    splitLetters(greeting_ch)
    convertToUpper(splitLetters.out.flatten())
    convertToUpper.out.view{ it }
}
----

In the example above, we can propagate the output of one process to another using the `.out` attribute. In this way, we now have a simpler workflow scope to follow, that creates custom functions from processes defined earlier in the script.

=== Process outputs

If a process defines two or more output channels, each of them can be accessed by indexing the `.out` attribute e.g. `.out[0]`, `.out[1]`, etc.

The process `output` definition also allows the use of the `emit` statment to define a named identifier that can be used to reference the channel in the external scope. For example:

[source,nextflow,linenums]
----
#!/usr/bin/env nextflow

nextflow.enable.dsl=2

params.greeting = 'Hello world!'
greeting_ch = Channel.from(params.greeting)

process splitLetters {

    input:
    val x

    output:
    file 'chunk_*'

    """
    printf '$x' | split -b 6 - chunk_
    """
}

process convertToUpper {

    input:
    file y

    output:
    stdout emit: verbiage

    """
    cat $y | tr '[a-z]' '[A-Z]'
    """
}

workflow {
    splitLetters(greeting_ch)
    convertToUpper(splitLetters.out.flatten())
    convertToUpper.out.verbiage.view{ it }
}
----

== Workflow

=== Workflow definition

The `workflow` scope allows the definition of components that define the invocation of one or more processes and operators:

[source,nextflow,linenums]
----
workflow my_pipeline {
    splitLetters(greeting_ch)
    convertToUpper(splitLetters.out.flatten())
    convertToUpper.out.verbiage.view{ it }
}

workflow {
    my_pipeline()
}
----

For example, the snippet above defines a `workflow` named `my_pipeline`, that can be invoked via another `workflow` definition.

=== Workflow parameters

A workflow component can access any variable and parameter defined in the outer scope. In the running example, we can also access `params.greeting` directly within the `workflow` definition.

[source,nextflow,linenums]
----
workflow my_pipeline {
    splitLetters(Channel.from(params.greeting))
    convertToUpper(splitLetters.out.flatten())
    convertToUpper.out.verbiage.view{ it }
}

workflow {
    my_pipeline()
}
----

=== Workflow inputs

A `workflow` component can declare one or more input channels using the `take` statement. For example:

[source,nextflow,linenums]
----
workflow my_pipeline {
    take:
    greeting

    main:
    splitLetters(greeting)
    convertToUpper(splitLetters.out.flatten())
    convertToUpper.out.verbiage.view{ it }
}
----

IMPORTANT: When the `take` statement is used, the `workflow` definition needs to be declared within the `main` block.

The input for the `workflow` can then be specified as an argument as shown below:

[source,nextflow,linenums]
----
workflow {
    my_pipeline(Channel.from(params.greeting))
}
----

=== Workflow outputs

A `workflow` can declare one or more output channels using the `emit` statement. For example:

[source,nextflow,linenums]
----
workflow my_pipeline {
    take:
    greeting

    main:
    splitLetters(greeting)
    convertToUpper(splitLetters.out.flatten())

    emit:
    convertToUpper.out.verbiage
}

workflow {
    my_pipeline(Channel.from(params.greeting))
    my_pipeline.out.view()
}
----

As a result, we can use the `my_pipeline.out` notation to access the outputs of `my_pipeline` in the invoking `workflow`.

We can also declare named outputs within the `emit` block.

[source,nextflow,linenums]
----
workflow my_pipeline {
    take:
    greeting

    main:
    splitLetters(greeting)
    convertToUpper(splitLetters.out.flatten())

    emit:
    my_data = convertToUpper.out.verbiage
}

workflow {
    my_pipeline(Channel.from(params.greeting))
    my_pipeline.out.my_data.view()
}
----

The result of the above snippet can then be accessed using `my_pipeline.out.my_data`.

== Modules

Nextflow DSL2 allows for the definition of stand-alone module scripts that can be included and shared across multiple workflows. Each module can contain it's own `process` or `workflow` definition.

=== Importing modules

Components defined in the module script can be imported into other Nextflow scripts using the `include` statement. This allows you to store these components in separate file(s) so that they can be re-used in multiple workflows.

Using the `hello.nf` example, we can acheive this by:

- Creating a file called `modules.nf` in the top-level folder containing the main Nextflow script.
- Cut and paste the two process definitions for `splitLetters` and `convertToUpper` into `modules.nf`.
- Import the processes from `modules.nf` within the main script anywhere above the `workflow` definition:

[source,nextflow,linenums]
----
include { splitLetters   } from './modules.nf'
include { convertToUpper } from './modules.nf'
----

NOTE: In general, you would use relative paths to define the location of the module scripts using the `./` prefix.

=== Multiple imports

If a Nextflow module script contains multiple `process` definitions these can also be imported using a single `include` statement as shown in the example below:

[source,nextflow,linenums]
----
include { splitLetters; convertToUpper } from './modules.nf'
----

=== Module aliases

When including a module component it is possible to specify a name alias using the `as` declaration. This allows the inclusion and the invocation of the same component multiple times in your script using different names. For example:

[source,nextflow,linenums]
----
#!/usr/bin/env nextflow

nextflow.enable.dsl=2

params.greeting = 'Hello world!'

include { splitLetters as splitLetters_one } from './modules.nf'
include { splitLetters as splitLetters_two } from './modules.nf'

include { convertToUpper as convertToUpper_one } from './modules.nf'
include { convertToUpper as convertToUpper_two } from './modules.nf'

workflow my_pipeline_one {
    take:
    greeting

    main:
    splitLetters_one(greeting)
    convertToUpper_one(splitLetters_one.out.flatten())

    emit:
    my_data = convertToUpper_one.out.verbiage
}

workflow my_pipeline_two {
    take:
    greeting

    main:
    splitLetters_two(greeting)
    convertToUpper_two(splitLetters_two.out.flatten())

    emit:
    my_data = convertToUpper_two.out.verbiage
}

workflow {
    my_pipeline_one(Channel.from(params.greeting))
    my_pipeline_one.out.my_data.view()

    my_pipeline_two(Channel.from(params.greeting))
    my_pipeline_two.out.my_data.view()
}
----

=== Parameter scopes

A module script can define one or more parameters or custom functions using the same syntax as with any other Nextflow script. Using the minimal examples below: 

[discrete]
==== Module script (`./modules.nf`)

[source,nextflow,linenums]
----
params.foo = 'Hello'
params.bar = 'world!'

def sayHello() {
    println "$params.foo $params.bar"
}
----

[discrete]
==== Main script (`./main.nf`)

[source,nextflow,linenums]
----
#!/usr/bin/env nextflow

nextflow.enable.dsl=2

params.foo = 'Hola'
params.bar = 'mundo!'

include { sayHello } from './modules.nf'

workflow {
    sayHello()
}
----

Running `main.nf` should print:

[source,bash,linenums]
----
Hola mundo!
----

As highlighted above, the script will print `Hola mundo!` instead of `Hello world!` because parameters are inherited from the including context.

TIP: To avoid being ignored, pipeline parameters should be defined at the beginning of the script before any `include` declarations.

The `addParams` option can be used to extend the module parameters without affecting the external scope. For example:

[source,nextflow,linenums]
----
#!/usr/bin/env nextflow

nextflow.enable.dsl=2

params.foo = 'Hola'
params.bar = 'mundo!'

include { sayHello } from './modules.nf' addParams(foo: 'Ciao')

workflow {
    sayHello()
}
----

Executing the main script above should print:

[source,bash,linenums]
----
Ciao world!
----

== DSL2 migration notes

To view a summary of the changes introduced when migrating from DSL1 to DSL2 please refer to the https://www.nextflow.io/docs/latest/dsl2.html#dsl2-migration-notes[DSL2 migration notes] in the official Nextflow documentation.

